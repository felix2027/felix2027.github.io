<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="G-F8JSPJ6LDD"><link rel="alternate" type="application/rss+xml" title="梁峯" href="https://blog.onlydoit.fun/rss.xml"><link rel="alternate" type="application/atom+xml" title="梁峯" href="https://blog.onlydoit.fun/atom.xml"><link rel="alternate" type="application/json" title="梁峯" href="https://blog.onlydoit.fun/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="教程"><link rel="canonical" href="https://blog.onlydoit.fun/2024/08/10/Introduction-to-data-structures/"><title>数据结构绪论 - 数据结构 | Felix = 梁峯</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构绪论</h1><div class="meta"><span class="item" title="创建时间：2024-08-10 15:33:25"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-08-10T15:33:25+08:00">2024-08-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>6.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>6 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Felix</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/31.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/23.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/24.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/44.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/134.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/felix2027/my_tools/main/Image_Hosting/background/39.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.onlydoit.fun/2024/08/10/Introduction-to-data-structures/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="梁峯"><meta itemprop="description" content=", Welcome to Felix's blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="梁峯"></span><div class="body md" itemprop="articleBody"><h2 id="数据结构绪论"><a class="anchor" href="#数据结构绪论">#</a> 数据结构绪论</h2><h3 id="数据结构概述"><a class="anchor" href="#数据结构概述">#</a> 数据结构概述</h3><p><strong>数据结构（D,R）</strong>，<strong>就是指数据元素之间的关系</strong>。</p><ul><li><strong>D</strong>（Data）数据元素集合</li><li><strong>R</strong>（Relation）数据元素之间的关系的集合</li></ul><blockquote><p>e.g.</p><p>数据结构被形式地定义为 (D, R)，其中 D 是数据元素的有限集合，R 是 D 上的关系有限集合。</p></blockquote><p><strong>数据结构</strong>就是指<strong>指数据元素之间的关系</strong>。</p><ul><li><p>基本概念和术语</p><ol><li>数据（Data）：<strong>数据</strong>是客观事物的符号表示，在计算机科学中是指所有能<strong>输入</strong>到计算机中并<strong>被计算机程序识别和处理的符号的总称</strong>。</li><li>数据对象（Data Object）：是<strong>性质相同的数据元素的集合</strong>，是数据的一个子集</li><li>数据元素（Data Element）：是数据的<strong>基本单位</strong>，在计算机程序中通常作为一个整体进行考虑和处理。<strong>一个数据元素可以由若干个数据项组成</strong>。一个存储结点存储一个数据元素</li><li>数据项（Data Item）：是数据处理中的<strong>最小单位</strong></li><li>结构 (Structure)：数据元素之间的关系。</li><li>数据结构 (Data Structure)：相互之间存在一种或多种特定关系的数据元素的集合。</li></ol><blockquote><p>数据：对客观事物的符号表示。在计算机科学中是指所有能输入到计算机并被计算机处理的符号总称。</p><p>数据元素：数据的基本单位。数据项的集合。数据的子集</p><p>数据结构：相互之间的存在一种或多种特定关系的数据元素的集合</p></blockquote></li><li><p>抽象数据类型</p><p>（Abstract Data Type，ADT）是抽象数据组织及与之相关的操作。用数学化的语言定义数据的逻辑结构、定义运算与具体的实现无关。</p><ol><li><p>数据类型：常用数据类型包括<strong>基本数据类型</strong>和<strong>构造数据类型</strong>。</p></li><li><p>抽象数据类型：（D，S，P）：</p><ul><li>D：数据对象</li><li>S：D 上的关系集</li><li>P：对 D 的基本操作集（增删改查）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    数据对象:&lt;数据对象的含义&gt;</span><br><span class="line">    数据关系:&lt;数据关系的定义&gt;</span><br><span class="line">    基本操作:&lt;基本操作的含义&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>e.g.<br>抽象数据类型的定义仅取决于它的一组<strong>逻辑特征</strong>，而与计算机内部如何表示和实现<strong>无关</strong>，即不论其内部结构如何变化，只要它的<strong>数学特征</strong>不变，都不影响其外部使用。</p></blockquote></li></ol></li></ul><h4 id="数据结构"><a class="anchor" href="#数据结构">#</a> 数据结构</h4><p>数据结构是相互之间存在<strong>一种或多种特定关系的数据元素的集合</strong>。在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（structure）。</p><blockquote><p>e.g.</p><p>数据结构是一门研究非数值运算的程序设计问题中计算机的<strong>数据</strong>以及它们之间的<strong>关系</strong>和运算等的学科。</p></blockquote><p>数据结构一般包括以下三方面内容。</p><ol><li><p>逻辑结构：</p><p>数据的逻辑结构是对数据元素之间逻辑关系的描述。它与<strong>数据的存储无关</strong>，是独立于计算机的。同一逻辑结构可以有多种结构存储，主要分为两类：<strong>线性结构和非线性结构</strong>。其中集合、树、图属于非线型结构。</p><blockquote><p>e.g.</p><p>同一种数据的逻辑结构，可以对应多种的不同<strong>存储结构</strong>。</p></blockquote><ul><li><p>集合：元素之间无关系。</p><p>结构中的数据元素之间除了 “同属一个集合 “外，别无其它的关系。</p></li><li><p><strong>线性</strong>：元素之间一对一的关系。</p><p>结构中的数据元素之间存在着一个对一个的关系，除了第一个元素，所有的元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。</p><blockquote><p>e.g.</p><p>线性结构除了首尾结点外，其它节点只有一个<strong>前驱结点</strong>和一个<strong>后继结点</strong>。</p><p>e.g.</p><p>一种数据结构的元素集合 K 和它的二元关系为：k={a,b,c,d,e,f,g,h},R={&lt;a,b&gt;,&lt;b,c&gt;,&lt;c,d&gt;,&lt;d,e&gt;,&lt;e,f&gt;,&lt;f,g&gt;,&lt;g,h&gt;} 则该数据结构具有<strong>线性</strong>结构</p><p>e.g.</p><p>在线性结构中，第一个结点<strong>没有</strong>前驱结点，其余每个结点有且只有<strong> 1 个</strong>前驱结点；最后一个结点<strong>没有</strong>后续结点，其余每个结点有且只有<strong> 1 个</strong>后续结点。</p></blockquote></li><li><p>树形：元素之间一对多的关系。</p><p>结构中的数据元素之间存在着一个对多个的关系</p><blockquote><p>e.g.</p><p>一种数据结构的元素集合 K 和它的二元关系为：k={a,b,c,d,e,f,g,h},R={&lt;d,b&gt;,&lt;d,g&gt;,&lt;b,a&gt;,&lt;b,c&gt;,&lt;g,e&gt;,&lt;g,h&gt;,&lt;e,f&gt;} 则该数据结构具有<strong>树型</strong>结构。</p></blockquote></li><li><p>图形：元素之间多对多的关系。</p><p>结构中的数据之间存在着多个对多个的关系</p></li></ul></li><li><p>物理结构（存储结构）：两种常用存储结构</p><p>常用的存储结构有两种：</p><ul><li><strong>顺序存储</strong>：逻辑相邻的元素在物理上<strong>也相邻</strong></li><li><strong>链式存储</strong>：逻辑相邻的元素在物理上<strong>不一定相邻</strong></li></ul><p>另外还有：</p><ul><li>索引存储：在存储元素信息的同时，建立附加的索引表。用结点的索引号来确定节点存储地址。优点是检索速度快，缺点是增加了额外的索引表，会占用较多的存储空间</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。根据结点的值确定它的存储地址。优点是检索、增加和删除节点的操作都很快。缺点是采用不好的散列函数时可能出现结点存储单元冲突，为解决冲突需要额外的时间和空间开销。</li></ul><table><thead><tr><th></th><th>顺序存储</th><th>链式存储</th></tr></thead><tbody><tr><td>优点</td><td>1. 可以实现随机存取<br>2. 每个元素占用最少的空间</td><td>充分利用所有存储单元，不会出现碎片现象</td></tr><tr><td>缺点</td><td>只能使用整块的存储单元，会产生较多的碎片</td><td>1. 需要额外存储空间用来放下一结点的指针。<br>2. 只能顺序存储。</td></tr></tbody></table><ol><li>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个元素在物理上可以是离散的。</li><li>数据的存储结构会影响存储空间分配的便利性。</li><li>数据的存储结构会影响数据运算的速度。</li></ol></li><li><p>数据的运算：</p><blockquote><p><strong>运算在逻辑结构</strong></p><p><strong>实现在存储结构</strong></p><p>施加在数据上的运算包括运算的定义和实现。<strong>运算的定义</strong>是针对<strong>逻辑结构</strong>的，指出运算的功能；<strong>运算的实现</strong>是针对<strong>存储结构</strong>的，指出运算的具体操作步骤。</p></blockquote><p>数据的运算即对数据施加的操作。数据的运算<strong>定义在数据的逻辑结构</strong>上，但是只有<strong>确定了存储结构</strong>，才能具体实现这些运算。数据的运算通常包括以下 5 个操作：</p><ul><li>插入：在指定位置上添加一个新结点。</li><li>删除：删去指定位置上的节点。</li><li>更新：修改某结点的值</li><li>查找：寻找满足指定条件的结点及其位置</li><li>排序：按指定的顺序使结点重新排列</li></ul></li><li><p>数据类型</p><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p><ol><li><strong>原子类型</strong>：其值不可再分的数据类型，如 <code>bool</code> 、 <code>int</code> 。</li><li><strong>结构类型</strong>：其值可以再分解为若干成分（分量）的数据类型，如 <code>struct student</code> 。</li></ol></li></ol><h3 id="算法及其复杂性概述"><a class="anchor" href="#算法及其复杂性概述">#</a> 算法及其复杂性概述</h3><blockquote><p><strong>程序 = 数据结构 + 算法</strong></p><p>算法 是<strong>对特定问题求解步骤的一种描述</strong>，是指令的有限序列。其中每一条指令表示一个或多个操作。</p></blockquote><h4 id="算法"><a class="anchor" href="#算法">#</a> 算法</h4><h5 id="算法的五个特性"><a class="anchor" href="#算法的五个特性">#</a> 算法的五个特性</h5><ol><li><strong>输入：0 个或多个输入</strong></li><li><strong>输出：1 个或多个输出</strong></li><li><strong>确定性</strong>：<strong>每一条指令必须有确切的含义，没有二义性</strong>，即对于相同的输入只能得出相同的输出。</li><li><strong>有穷性：算法中描述的操作都是可以通过已实现的基本运算执行有限次来实现的。</strong></li><li><strong>可行性：一个算法描述的操作是可行的。</strong></li></ol><h5 id="算法的四个要求"><a class="anchor" href="#算法的四个要求">#</a> 算法的四个要求</h5><ol><li><strong>正确性</strong>：算法应满足具体问题需求，设计或选择的算法应能正确反映这种需求。</li><li><strong>健壮性</strong>：当输入数据非法时，算法也能适当地作出反应或处理，而不会产生莫名其妙的输出结果。</li><li><strong>可读性</strong>：算法主要是为了人阅读及人与人之间的交流，其次才是机器执行。可读性好有助于对算法的理解。晦涩难懂的程序易于隐藏错误，难以调试和修改。</li><li><strong>高效率低存储</strong>：效率指的是算法执行时间。若有多个算法可解决同一问题，则执行时间短的算法效率高。存储需求指的是执行过程所需的最大存储空间。</li></ol><h5 id="算法复杂性的概念"><a class="anchor" href="#算法复杂性的概念">#</a> 算法复杂性的概念</h5><blockquote><p>评价一个程序优劣的重要依据是看该程序的执行需要占用多少机器资源。在各种机器资源中，最重要的是<strong>时间</strong>资源和<strong>空间</strong>资源。</p><p>因此，在进行程序分析时，大家最关心的就是程序所用算法在运行时所要花费的时间代价和程序中使用的数据结构所占有的空间代价。通常称之为<strong>时间复杂度（时间代价）<strong>和</strong>空间复杂度（空间代价）</strong>。</p><p>算法执行时间需要通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。</p></blockquote><blockquote><p>e.g.</p><p>一个算法的效率可分为<strong>时间</strong>效率和<strong>空间</strong>效率</p></blockquote><h4 id="算法的时间复杂度"><a class="anchor" href="#算法的时间复杂度">#</a> 算法的时间复杂度</h4><blockquote><p>时间复杂度是指算法中所有语句的频度（执行次数）之和。</p><p>在一般情况下，算法中 “基本操作” 重复执行的次数是问题规模 n 的某个函数 f (n)，算法的时间度量记作： <code>T(n) = O(f(n))</code> ，它表示随<strong>问题规模 n</strong> 的增大，算法执行时间的增长率和 f (n) 的增长率相同。</p><p>时间复杂度（T (n)）取决于基本操作的执行次数，也叫频度。基本操作的频度用 T (n) 表示。</p><p>由于算法时间复杂度分析只考虑相对于问题规模 n 的增长率，因而在难以精确计算基本操作执行次数的情况下，只要求出它关于 n 的增长率即可。我们可以在计算任何算法运行时间代价的时候，<strong>忽略所有的常数和低次项，用大 O 表示法来表示算法的时间复杂度</strong></p><p>先分析基本操作的频度，然后取数量级，数量级最高的频度决定了时间复杂度的数量级。</p></blockquote><blockquote><p>e.g. 下述程序段中语句 <code>s+=j;</code> 的频度是？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;j&lt;m;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">s+=j;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据高斯公式：&amp;a+…+b=(a+b)(b-a+1)/2&amp;\\</span><br><span class="line">&amp;2+3+4+...+m=(m+2)(m-1)/2&amp;\\</span><br><span class="line">答案为：&amp;(m+2)(m-1)/2&amp;</span><br></pre></td></tr></table></figure></blockquote><p>时间复杂度的推导过程</p><ol><li><p>分析基本操作的频度</p></li><li><p>取数量级</p></li><li><p>数量级最高的频度决定了时间复杂度的数量级</p><p>常用技巧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;加法:&amp;O(f(n))+O(g(n))=O(max(f(n),g(n)))\\</span><br><span class="line">&amp;乘法:&amp;O(f(n)*O(g(n)))=O(f(n)*g(n))</span><br></pre></td></tr></table></figure><ul><li><p>常数阶</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1+1+1&amp;=&amp;3	//求运行次数之和 \\</span><br><span class="line">1&amp;=&amp;n^0	//用1取代所有加法常数\\</span><br><span class="line">T(n)&amp;=&amp;n^0	//保留最高阶项</span><br></pre></td></tr></table></figure><p>T(n)=O(f(n))=O(1)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br></pre></td></tr></table></figure></li><li><p>线性阶</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分析基本操作的频度，然后取数量级 &amp;T(n)=O(1)+O(n)&amp;\\</span><br><span class="line">化简&amp;T(n)=O(n)&amp;\\</span><br></pre></td></tr></table></figure><p>T(n)=O(f(n))=O(n)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="comment">//代码块内O(1)的步骤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对数阶</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分析基本操作的频度 &amp;2^t+1^\frac&#123;n&#125;&#123;2&#125;&amp;\\</span><br><span class="line">取数量级 &amp;T(n)=O(\log_&#123;2&#125;^\frac&#123;n&#125;&#123;2&#125;-1)+O(1)&amp;\\</span><br><span class="line">化简&amp;T(n)=O(f(n))=O(\log_2^n)&amp;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)&#123;</span><br><span class="line">    x=<span class="number">2</span>*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nlog_2^n</span><br></pre></td></tr></table></figure><p>外层 n，内层 log<sub>2</sub>n</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,x=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)&#123;</span><br><span class="line">        x=<span class="number">2</span>*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>平方阶</p><blockquote><p>n*n+1	// 求运行次数之和<br>n<sup>2</sup>+n<sup>0</sup>	// 用 1 取代所有加法常数<br>n<sup>2</sup>	// 保留最高阶<br>T (n)=O (f (n))=O (n<sup>2</sup>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n*n+1	\\</span><br><span class="line">n^2+n^0	\\</span><br><span class="line">n^2\\	</span><br><span class="line">T(n)=O(f(n))=O(n^2)</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>常见的时间复杂度比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行次数函数  &amp;O阶&amp;       非正式用语\\</span><br><span class="line">12                 &amp;O(1)&amp;         常数阶\\</span><br><span class="line">2n+3               &amp;O(n)&amp;         线性阶\\ </span><br><span class="line">3n^2+2n+1         &amp;O(n^2)&amp;       平方阶\\  </span><br><span class="line">5log_2^n+20      &amp;O(log_2^n)&amp;  对数阶\\  </span><br><span class="line">2n+3nlog_2^n+19  &amp;O(nlog_2^n)&amp;  nlogn阶\\    </span><br><span class="line">6n^3+2n^2+3n+4   &amp;O(n^3)&amp;      立方阶\\</span><br><span class="line">2^n             &amp;O(2^n)&amp;      指数阶 \\</span><br></pre></td></tr></table></figure><p>常用的时间复杂度所消耗的时间从小到大依次是：</p><p><strong>常对幂指阶</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</span><br></pre></td></tr></table></figure><p>最坏情况与平均情况</p><blockquote><p>对算法的分析，一种方法是计算所有情况的平均值，这种时间复杂度的计算方法称为<strong>平均</strong>时间复杂度。另一种方法是计算最坏情况下的时间复杂度，这种方法称为<strong>最坏</strong>时间复杂度。一般在没有特殊说明的情况下，都是指最坏时间复杂度</p></blockquote><blockquote><p>e.g.</p><p>分析下面算法，给出最大语句频度<strong> n (n-1)/2</strong>, 该算法的二时间复杂度是<strong> O (n^2)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">  a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="算法的空间复杂度"><a class="anchor" href="#算法的空间复杂度">#</a> 算法的空间复杂度</h4><blockquote><p>算法的空间复杂度通过计算算法所需存储空间实现，算法空间复杂度的计算公式基座：S (n)=O (f (n)), 表示随着问题规模 n 的增大，算法运行所需存储量的增长与 f (n）的增长率</p><p>算法的存储量包括：</p><p>​ 输入程序所占<strong>空间</strong></p><p>​ 程序本身所占<strong>空间</strong></p><p>​ 辅助变量所占<strong>空间</strong></p><p>S(n)=O(f(n))</p><p>若输入数据所占空间只取决与问题本身，和算法无关，则只需要分析出输入和程序之外的额外空间。</p><p>算法原地工作指的是额外空间相对于输入数据量来说是常数。</p><p>n 个元素数组排序，不使用额外的空间（随着 n 的增长而增长的空间叫额外空间），空间复杂度就是 O (1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RevArray(<span class="type">int</span> a[],<span class="type">int</span> n)&#123;</span><br><span class="line"> <span class="type">int</span> i,j;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">     a[i]+=a[j];</span><br><span class="line">     a[j]=a[i]-a[j];</span><br><span class="line">     a[i]-=a[j];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	执行了n/2次</span></span><br><span class="line"><span class="comment">	所以T(n)=n/2=O(n)</span></span><br><span class="line"><span class="comment">	辅助空间只有i,j,所以S(n)=2=O(1)</span></span><br><span class="line"><span class="comment">	而因为这里使用的辅助空间，不会随着问题的规模变化而变化，简而言之，就是常量级别的，我们就称其为原地工作</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></blockquote><p>空间复杂度 S (n) 定义为该算法所耗费的存储空间，它是问题规模 n 的函数。</p><p>计算公式： <code>S(n) = O(f(n))</code> 。</p><p>空间复杂度的主要关注点是<strong>辅助空间</strong>，即算法所需的额外空间（除了输入数据的存储空间外）。</p><ul><li>空间复杂度不包括输入和输出所需的空间。</li><li>主要衡量算法的辅助空间。</li></ul><p>无论问题规模怎么变，算法运行所需的内存空间都是固定的常量。</p><ul><li><p>普通程序</p><ol><li>找到所占空间大小与问题规模相关的变量</li><li>分析所占空间 x 与问题规模 n 的关系 x=f (n)</li><li>x 的数量级 O (x) 就是算法空间复杂度 S (n)</li></ol></li><li><p>递归程序</p><ol><li>找到递归调用的深度 x 与问题规模 n 的关系 x=f (n)</li><li>x 的数量级 O (x) 就是算法空间复杂度 S (n)</li></ol><p>注：有的算法各层函数所需存储空间不同，分析方法略有不同</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(O)=O(n^2)+O(n)+n(1)=O(n^2)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> flag[n][n];</span><br><span class="line">    <span class="type">int</span> other[n];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//S(O)=O(n^2)+O(n)+n(1)=O(n^2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(O)=O(n)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        test(--n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//S(O)=O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S(O)=O(n^2)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test(int n)&#123;</span><br><span class="line">    int flag[4]=&#123;0&#125;;</span><br><span class="line">    if(n&gt;1)&#123;</span><br><span class="line">        test(--n);</span><br><span class="line">    &#125;</span><br><span class="line">    //S(O)=O(n^2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tags"><a href="/tags/%E6%95%99%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> 教程</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-13 16:42:02" itemprop="dateModified" datetime="2024-08-13T16:42:02+08:00">2024-08-13</time> </span><span id="2024/08/10/Introduction-to-data-structures/" class="item leancloud_visitors" data-flag-title="数据结构绪论" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Felix <i class="ic i-at"><em>@</em></i>梁峯</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.onlydoit.fun/2024/08/10/Introduction-to-data-structures/" title="数据结构绪论">https://blog.onlydoit.fun/2024/08/10/Introduction-to-data-structures/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/08/05/create-new-blog-with-hexo/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;felix2027&#x2F;my_tools&#x2F;main&#x2F;Image_Hosting&#x2F;background&#x2F;150.jpg" title="使用 Hexo 发布文章"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> blog</span><h3>使用 Hexo 发布文章</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">数据结构绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E5%A4%8D%E6%9D%82%E6%80%A7%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">算法及其复杂性概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%94%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">算法的五个特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9B%9B%E4%B8%AA%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">算法的四个要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">算法复杂性的概念</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">算法的时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">算法的空间复杂度</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/08/10/Introduction-to-data-structures/" rel="bookmark" title="数据结构绪论">数据结构绪论</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="梁峯" data-src="/images/avatar.jpg"><p class="name" itemprop="name">梁峯</p><div class="description" itemprop="description">Welcome to Felix's blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">3</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">2</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZlbGl4MjAyNw==" title="https:&#x2F;&#x2F;github.com&#x2F;felix2027"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE4NDg0NDIxNTU=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1848442155"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmZlaWxpeDIwMjdAZ21haWwuY29t" title="mailto:feilix2027@gmail.com"><i class="ic i-envelope"></i></span> <span class="exturl item youtube" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vY2hhbm5lbC9VQ2wtYjloaHZLNWFOUk5CUzdMMjJubGc=" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCl-b9hhvK5aNRNBS7L22nlg"><i class="ic i-youtube"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/curriculum-vitae" rel="section"><i class="ic i-user"></i>简历</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/blog/" title="分类于 blog">blog</a></div><span><a href="/2024/08/05/create-new-blog-with-hexo/" title="使用 Hexo 发布文章">使用 Hexo 发布文章</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a></div><span><a href="/2024/08/10/Introduction-to-data-structures/" title="数据结构绪论">数据结构绪论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/blog/" title="分类于 blog">blog</a></div><span><a href="/2024/08/03/how-to-build-a-site-with-hexo/" title="使用 Hexo 搭建网站，并部署至github">使用 Hexo 搭建网站，并部署至github</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-峯"></i> </span><span class="author" itemprop="copyrightHolder">梁峯 @ Felix</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">11k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/08/10/Introduction-to-data-structures/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(t){return t.includes("#")},function(t){return new RegExp(LOCAL.path+"$").test(t)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>